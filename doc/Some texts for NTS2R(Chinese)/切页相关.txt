一切程序都是基于C6E1/C6E3系统切页

先定义一个东西 一个叫底页 一个叫顶页 这两块是不能同时载入RAM中执行的

$43内存是记录底页rom编号值 $44内存是记录顶页编号值

一般情况下是不强行写入$43的值

C6FE-C714是定义好的底页相关操作 写常用的底页

日文文档有详细解释

可以模仿底页操作 写A9 XX 20 E3 C6

这就切到XX页了

20 e1 c6是从顶页切回底页的操作

单独切顶页是A9 XX 20 E5 C6 

这个切页操作的核心操作是执行了c720的相关代码

汉化程序与我自己写的程序杂糅了。。


 3F:C720:4C 62 54  JMP $5462		;之前寄存器A获取了切页的编号
   :5462:8D 03 50  STA $5003 = #$3C	;这个是汉化相关的代码
   :5465:48        PHA			;这个是保护切页编号
   :5466:A9 06     LDA #$06
   :5468:4C 23 C7  JMP $C723
 3F:C723:8D 00 80  STA $8000 = #$20	;数值06向端口8000写入 代表切换ram块$8000-9fff
 3F:C726:68        PLA			;弹出切页编号
 3F:C727:8D 01 80  STA $8001 = #$35	;向端口8001写入rom页编号 8000-9fff内容改变
;中间都是NOP跳过代码 就不谢了
 3F:C735:4C 6B 54  JMP $546B
   :546B:48        PHA
   :546C:A9 07     LDA #$07
   :546E:8D 00 80  STA $8000 = #$20	;以上同理 不过07代表$a000-$bfff
   :5471:68        PLA
   :5472:18        CLC
   :5473:69 01     ADC #$01
   :5475:8D 01 80  STA $8001 = #$35	;这rom编号+1 程序运行总共切两页
   :5478:60        RTS -----------------------------------------


 3F:C759:A5 43     LDA $0043 = #$3C
 3F:C75B:85 45     STA $0045 = #$3C	;首先备份底页码 使其配合c770使用
 3F:C75D:68        PLA
 3F:C75E:85 F3     STA $00F3 = #$01
 3F:C760:68        PLA
 3F:C761:85 F4     STA $00F4 = #$85	;这个代码用20跳入的话 会压入执行前PC计数器 以此为基址 获取以后的内容
 3F:C763:A0 01     LDY #$01
 3F:C765:B1 F3     LDA ($F3),Y @ $8501 = #$D0
 3F:C767:99 00 06  STA $0600,Y @ $0600 = #$00
 3F:C76A:C8        INY
 3F:C76B:D0 F8     BNE $C765		;反复字节获取内容 复制到$0601中
 3F:C76D:4C 01 06  JMP $0601		;然后开始执行0601程序（注意 此时RTS已经不能返回调用的20程序了 因为他们被弹出了）


 3F:C770:86 F2     STX $00F2 = #$07	;备份当前寄存器X内容
 3F:C772:BA        TSX			;获取栈指针
 3F:C773:68        PLA
 3F:C774:68        PLA			;弹出20压入的栈基址（实质上只是修改了栈指针）
 3F:C775:BD 01 01  LDA $0101,X @ $0101 = #$00
 3F:C778:85 F3     STA $00F3 = #$01
 3F:C77A:BD 02 01  LDA $0102,X @ $0102 = #$00
 3F:C77D:85 F4     STA $00F4 = #$85	;获取到原来的基址（因为栈指针改变并没有改变压入的内容 所以还驻留在内存中）
 3F:C77F:A0 02     LDY #$02
 3F:C781:B1 F3     LDA ($F3),Y @ $8501 = #$D0
 3F:C783:48        PHA
 3F:C784:88        DEY
 3F:C785:B1 F3     LDA ($F3),Y @ $8501 = #$D0
 3F:C787:48        PHA			;把想要跳到的PC地址写入栈中 让RTS正确的跳转
 3F:C788:A6 F2     LDX $00F2 = #$07	;恢复寄存器X
 3F:C78A:A5 45     LDA $0045 = #$3C	;读取备份的底页码 准备执行切页操作
 3F:C78C:4C E3 C6  JMP $C6E3

20 59 C7 A9 zz 20 e3 c6 4c xx yy
MM MM MM MM 20 70 c7 xx yy


 .ORG $8401
 JSR $c759
 LDA #$40
 JSR $c6e3
 JMP $8000 ;此时跳转的物理地址是80010
 ;假设后面的地址是8501 原来底页是3C
 .ORG $8501
 
 
 .ORG $8000
 ;程序XX
 JSR $c770
 .DB $01
 .DB $85 ;程序就跳回原来的底页的8501 也就是7C511
 